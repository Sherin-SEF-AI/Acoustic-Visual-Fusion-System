"""
Zone Manager - Define and monitor spatial zones for activity tracking.
"""

import json
from pathlib import Path
from dataclasses import dataclass, asdict, field
from typing import Optional, Callable
import numpy as np
from loguru import logger
from enum import Enum
import time


class ZoneType(Enum):
    MONITORING = "monitoring"
    RESTRICTED = "restricted"  
    QUIET = "quiet"
    PRESENTATION = "presentation"
    CUSTOM = "custom"


class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class Zone:
    """Represents a spatial zone in the scene."""
    zone_id: str
    name: str
    zone_type: ZoneType
    
    # 3D bounding box (min_x, min_y, min_z, max_x, max_y, max_z)
    bounds: tuple[float, float, float, float, float, float]
    
    # Rules
    max_persons: int = -1  # -1 = unlimited
    max_sound_db: float = -1  # -1 = no limit
    allowed_hours: tuple[int, int] = (0, 24)  # Start and end hour
    
    # State
    current_persons: int = 0
    current_sound_db: float = 0.0
    is_active: bool = True
    
    # Style
    color: str = "#00ff88"
    opacity: float = 0.3
    
    metadata: dict = field(default_factory=dict)
    
    def contains_point(self, x: float, y: float, z: float = 0) -> bool:
        """Check if a point is inside the zone."""
        min_x, min_y, min_z, max_x, max_y, max_z = self.bounds
        return (min_x <= x <= max_x and 
                min_y <= y <= max_y and
                min_z <= z <= max_z)
    
    def to_dict(self) -> dict:
        data = asdict(self)
        data['zone_type'] = self.zone_type.value
        return data
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Zone':
        data['zone_type'] = ZoneType(data['zone_type'])
        data['bounds'] = tuple(data['bounds'])
        data['allowed_hours'] = tuple(data['allowed_hours'])
        return cls(**data)


@dataclass
class ZoneAlert:
    """Alert generated by zone violation."""
    alert_id: str
    zone_id: str
    zone_name: str
    alert_type: str
    level: AlertLevel
    message: str
    timestamp: float
    metadata: dict = field(default_factory=dict)


class ZoneManager:
    """
    Manages spatial zones and monitors for violations.
    """
    
    def __init__(self, config_path: str = "config/zones.json"):
        self.config_path = Path(config_path)
        self.zones: dict[str, Zone] = {}
        
        # Alert callbacks
        self.alert_callbacks: list[Callable[[ZoneAlert], None]] = []
        
        # Alert history
        self.alerts: list[ZoneAlert] = []
        self.max_alerts = 1000
        
        # Cooldown to prevent alert spam
        self.alert_cooldown: dict[str, float] = {}
        self.cooldown_seconds = 10.0
        
        self._load_zones()
        logger.info(f"ZoneManager initialized: {len(self.zones)} zones")
    
    def _load_zones(self):
        """Load zones from config file."""
        if self.config_path.exists():
            try:
                with open(self.config_path) as f:
                    data = json.load(f)
                for zone_data in data.get("zones", []):
                    zone = Zone.from_dict(zone_data)
                    self.zones[zone.zone_id] = zone
            except Exception as e:
                logger.error(f"Failed to load zones: {e}")
    
    def _save_zones(self):
        """Save zones to config file."""
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        data = {
            "zones": [z.to_dict() for z in self.zones.values()],
            "updated_at": time.time()
        }
        with open(self.config_path, 'w') as f:
            json.dump(data, f, indent=2)
    
    def create_zone(self, name: str, zone_type: ZoneType,
                    bounds: tuple, **kwargs) -> Zone:
        """Create a new zone."""
        zone_id = f"zone_{len(self.zones)}_{int(time.time())}"
        
        zone = Zone(
            zone_id=zone_id,
            name=name,
            zone_type=zone_type,
            bounds=bounds,
            **kwargs
        )
        
        self.zones[zone_id] = zone
        self._save_zones()
        
        logger.info(f"Created zone: {name} ({zone_type.value})")
        return zone
    
    def update_zone(self, zone_id: str, **kwargs) -> Optional[Zone]:
        """Update zone properties."""
        if zone_id not in self.zones:
            return None
        
        zone = self.zones[zone_id]
        for key, value in kwargs.items():
            if hasattr(zone, key):
                setattr(zone, key, value)
        
        self._save_zones()
        return zone
    
    def delete_zone(self, zone_id: str) -> bool:
        """Delete a zone."""
        if zone_id not in self.zones:
            return False
        
        del self.zones[zone_id]
        self._save_zones()
        return True
    
    def get_zone_at_point(self, x: float, y: float, z: float = 0) -> Optional[Zone]:
        """Get zone containing a point."""
        for zone in self.zones.values():
            if zone.is_active and zone.contains_point(x, y, z):
                return zone
        return None
    
    def get_zones_for_track(self, bbox: np.ndarray) -> list[Zone]:
        """Get all zones that a track (bounding box) intersects."""
        result = []
        for zone in self.zones.values():
            if not zone.is_active:
                continue
            
            # Use center of bbox
            cx = (bbox[0] + bbox[2]) / 2
            cy = (bbox[1] + bbox[3]) / 2
            
            if zone.contains_point(cx, cy, 0):
                result.append(zone)
        
        return result
    
    def update_zone_state(self, zone_id: str, 
                          persons: int = None,
                          sound_db: float = None):
        """Update zone's current state and check for violations."""
        if zone_id not in self.zones:
            return
        
        zone = self.zones[zone_id]
        
        if persons is not None:
            zone.current_persons = persons
            
            # Check person limit
            if zone.max_persons > 0 and persons > zone.max_persons:
                self._raise_alert(
                    zone, "occupancy_exceeded",
                    AlertLevel.WARNING,
                    f"Zone '{zone.name}' has {persons} persons (max: {zone.max_persons})"
                )
        
        if sound_db is not None:
            zone.current_sound_db = sound_db
            
            # Check sound limit (for quiet zones)
            if zone.max_sound_db > 0 and sound_db > zone.max_sound_db:
                level = AlertLevel.CRITICAL if zone.zone_type == ZoneType.QUIET \
                        else AlertLevel.WARNING
                self._raise_alert(
                    zone, "sound_exceeded",
                    level,
                    f"Zone '{zone.name}' sound level: {sound_db:.1f}dB (max: {zone.max_sound_db}dB)"
                )
    
    def check_restricted_access(self, zone: Zone, person_id: str = None) -> bool:
        """Check if access to a restricted zone should be alerted."""
        if zone.zone_type != ZoneType.RESTRICTED:
            return True
        
        # Check time restrictions
        current_hour = time.localtime().tm_hour
        start, end = zone.allowed_hours
        
        if not (start <= current_hour < end):
            self._raise_alert(
                zone, "after_hours_access",
                AlertLevel.CRITICAL,
                f"Access to restricted zone '{zone.name}' outside allowed hours"
            )
            return False
        
        return True
    
    def _raise_alert(self, zone: Zone, alert_type: str, 
                     level: AlertLevel, message: str):
        """Raise an alert for a zone violation."""
        # Check cooldown
        key = f"{zone.zone_id}_{alert_type}"
        now = time.time()
        
        if key in self.alert_cooldown:
            if now - self.alert_cooldown[key] < self.cooldown_seconds:
                return
        
        self.alert_cooldown[key] = now
        
        alert = ZoneAlert(
            alert_id=f"alert_{int(now * 1000)}",
            zone_id=zone.zone_id,
            zone_name=zone.name,
            alert_type=alert_type,
            level=level,
            message=message,
            timestamp=now
        )
        
        self.alerts.append(alert)
        if len(self.alerts) > self.max_alerts:
            self.alerts = self.alerts[-self.max_alerts:]
        
        # Notify callbacks
        for callback in self.alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                logger.error(f"Alert callback error: {e}")
        
        logger.warning(f"Zone alert [{level.value}]: {message}")
    
    def add_alert_callback(self, callback: Callable[[ZoneAlert], None]):
        """Register a callback for zone alerts."""
        self.alert_callbacks.append(callback)
    
    def get_recent_alerts(self, count: int = 50) -> list[ZoneAlert]:
        """Get recent alerts."""
        return self.alerts[-count:]
    
    def get_zone_summary(self) -> dict:
        """Get summary of all zones."""
        return {
            "total_zones": len(self.zones),
            "active_zones": sum(1 for z in self.zones.values() if z.is_active),
            "zones": [
                {
                    "id": z.zone_id,
                    "name": z.name,
                    "type": z.zone_type.value,
                    "persons": z.current_persons,
                    "sound_db": z.current_sound_db
                }
                for z in self.zones.values()
            ]
        }
    
    def create_default_zones(self):
        """Create default zone layout."""
        # Room center
        self.create_zone(
            "Main Area",
            ZoneType.MONITORING,
            (-4, -4, 0, 4, 4, 3),
            color="#00ff88"
        )
        
        # Presentation zone
        self.create_zone(
            "Presentation Zone",
            ZoneType.PRESENTATION,
            (-2, -4, 0, 2, -2, 3),
            max_persons=1,
            color="#6496ff"
        )
        
        # Quiet zone
        self.create_zone(
            "Quiet Zone",
            ZoneType.QUIET,
            (2, 2, 0, 4, 4, 3),
            max_sound_db=40.0,
            color="#ffd93d"
        )
